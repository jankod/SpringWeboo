• ThreadLocal u WebPageContext je u redu ako ga strogo kontroliraš (set na početku rendera, clear u finally). Alternativa je držati ga u WebooUtil, ali bolje je da kontekst upravlja sam sobom. Ključ je: ne izlagati ThreadLocal javno i
  uvijek ga čistiti.

  Kako bih to složio:

  1. Page.render lifecycle (set/clear)

  @Override
  public void render(Map<String, ?> model, HttpServletRequest req, HttpServletResponse res) throws Exception {
      res.setContentType("text/html");
      res.setCharacterEncoding("UTF-8");

      WebPageContext ctx = new WebPageContext(model, req, res);
      try {
          render(ctx); // korisnički kod: add widgete, set title, layout
          Layout layoutToUse = layout != null ? layout : new TablerLayout();
          LayoutModel lm = layoutToUse.createModel(ctx, this); // vidi ispod
          String html = layoutToUse.toHtml(lm);
          res.getWriter().write(html);
      } finally {
          WebPageContext.clearCurrentContext();
      }
  }

  WebPageContext konstruktor postavlja ThreadLocal.

  2. LayoutModel (de-couple Page od Layout)

  public record LayoutModel(
      String title,
      String bodyHtml,
      Widget headSlot,
      Widget bodyTopSlot,
      Widget bodyFooterSlot,
      String scriptCode,
      WebPageContext context
  ) {}

  3. Layout API

  public interface Layout {
      LayoutModel createModel(WebPageContext ctx, Page page);

      String toHtml(LayoutModel model);

      default String createScriptJsCode(LayoutModel model) { ... } // koristi model.bodyHtml ili model.context
  }

  TablerLayout primjer:

  @Override
  public LayoutModel createModel(WebPageContext ctx, Page page) {
      String bodyHtml = WebooUtil.widgetToHtml(page.getWidgets());
      return new LayoutModel(
          page.getTitle(),
          bodyHtml,
          headSlot,
          bodyTopSlot,
          bodyFooterSlot,
          createScriptJsCode(page), // ili iz modela
          ctx
      );
  }

  @Override
  public String toHtml(LayoutModel m) {
      String tpl = """
          <!doctype html>
          <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>{title}</title>
            <link rel="stylesheet" href="tabler.min.css">
            {scriptCode.raw}
            {headSlot or ""}
          </head>
          <body>
            {bodyTopSlot or ""}
            <div class="container">
              {bodyHtml.raw}
            </div>
            {bodyFooterSlot or ""}
            <script src="tabler.min.js"></script>
          </body>
          </html>
          """;
      return QuteUtil.quteThis(tpl, m);
  }

  Sad Layout više ne mora znati detalje Page-a; dobije gotov model.

  4. Widget + kontekst
     Ako trebaš pristup requestu/modelu u widgetima, promijeni potpis:

  public abstract class Widget {
      public abstract String toHtml(WebPageContext ctx);

      public final String toHtml() {
          return toHtml(WebPageContext.getCurrentContext());
      }
  }

  I Widget implementacije koriste ctx kad treba.

  5. CompositeWidget/HasChildren ostaje, ali koristi toHtml(ctx):

  protected String renderChildren(WebPageContext ctx) {
      return children.stream()
          .map(w -> w.toHtml(ctx))
          .collect(joining("\n"));
  }

  6. Id generation i debug info ostaje, samo se poziva kroz WebPageContext.getCurrentContext(); pošto clean-up ide u finally, nema curenja.

  Sumirano: ThreadLocal može ostati u WebPageContext uz obavezno try/finally. Model izdvoji (LayoutModel) da Layout ne ovisi o Page-u, i proširi Widget API s kontekstom da se otvore mogućnosti (request, model, i18n) bez globalnog state-
  a.
